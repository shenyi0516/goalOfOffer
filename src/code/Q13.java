package code;

/**
 * @author Shen Yi
 * @version 1.0
 * @date 2020/3/25 15:36
 */

/**
 * 给出一个矩阵，机器人从（0,0）处出发，每次可以向四周移动一个格子，但不能进入数位和大于k的格子，求最终能到达几个格子。
 * 思路：使用DFS或者BFS，当机器人不能进入当前单元格时回溯。
 * 输入参数：矩阵、当前位置、已经访问过的位置。
 * 剪枝工作：
 * 1.矩阵越界。
 * 2.当前位置不可进入。
 * 3.当前位置已经访问过。
 * 解的三角形结构：
 * 根据数位和特点，矩阵中 满足数位和的解 构成的几何形状形如多个 等腰直角三角形 ，每个三角形的直角顶点位于 0, 10, 20, ...0,10,20,... 等数位和突变的矩阵索引处 。
 * 三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。
 * 结论： 根据可达解的结构，易推出机器人可 仅通过向右和向下移动，访问所有可达解 。
 * 三角形内部： 全部连通，易证；
 * 两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。
 *所以只要向右或者向下递推即可。
 * 递推工作：
 * 1。标记当前位置。
 * 2.向右或者向下递推。
 * 3.由于这次同一个单元格即使用不同路径到达也只能算一次，所以不需要还原当前位置。
 */
public class Q13 {
    int[][] visited;
    public int movingCount(int m, int n, int k) {
        int count;
        visited = new int[m][n];
        count = dfs(m,n,0,0,k);
        return count;
    }

    private int dfs(int m, int n, int i, int j, int k) {
        if(i<0||j<0||i>=m||j>=n||sum(i,j)>k||visited[i][j] == 1)
            return 0;
        visited[i][j] = 1;
        return  1+dfs(m,n,i+1,j,k)+dfs(m,n,i,j+1,k);
    }

    int sum(int i,int j){
        int sumI = 0;
        int sumJ = 0;
        while(i!=0){
            sumI += i%10;
            i = i/10;
        }
        while (j!=0){
            sumJ += j%10;
            j = j/10;
        }
        return sumI+sumJ;
    }
}
